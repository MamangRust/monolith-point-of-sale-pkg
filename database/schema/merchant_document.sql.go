// Code generated by sqlc. DO NOT EDIT.
// versions:
//   sqlc v1.27.0
// source: merchant_document.sql

package db

import (
	"context"
	"database/sql"
)

const createMerchantDocument = `-- name: CreateMerchantDocument :one
INSERT INTO merchant_documents (
    merchant_id, document_type, document_url, status, note, uploaded_at, updated_at
) VALUES (
    $1, $2, $3, $4, $5, current_timestamp, current_timestamp
)
RETURNING document_id, merchant_id, document_type, document_url, status, note, uploaded_at, created_at, updated_at, deleted_at
`

type CreateMerchantDocumentParams struct {
	MerchantID   int32          `json:"merchant_id"`
	DocumentType string         `json:"document_type"`
	DocumentUrl  string         `json:"document_url"`
	Status       string         `json:"status"`
	Note         sql.NullString `json:"note"`
}

func (q *Queries) CreateMerchantDocument(ctx context.Context, arg CreateMerchantDocumentParams) (*MerchantDocument, error) {
	row := q.db.QueryRowContext(ctx, createMerchantDocument,
		arg.MerchantID,
		arg.DocumentType,
		arg.DocumentUrl,
		arg.Status,
		arg.Note,
	)
	var i MerchantDocument
	err := row.Scan(
		&i.DocumentID,
		&i.MerchantID,
		&i.DocumentType,
		&i.DocumentUrl,
		&i.Status,
		&i.Note,
		&i.UploadedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const deleteAllPermanentMerchantDocuments = `-- name: DeleteAllPermanentMerchantDocuments :exec
DELETE FROM merchant_documents
WHERE deleted_at IS NOT NULL
`

func (q *Queries) DeleteAllPermanentMerchantDocuments(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, deleteAllPermanentMerchantDocuments)
	return err
}

const deleteMerchantDocumentPermanently = `-- name: DeleteMerchantDocumentPermanently :exec
DELETE FROM merchant_documents
WHERE
    document_id = $1 AND deleted_at IS NOT NULL
`

func (q *Queries) DeleteMerchantDocumentPermanently(ctx context.Context, documentID int32) error {
	_, err := q.db.ExecContext(ctx, deleteMerchantDocumentPermanently, documentID)
	return err
}

const getActiveMerchantDocuments = `-- name: GetActiveMerchantDocuments :many
SELECT document_id, merchant_id, document_type, document_url, status, note, uploaded_at, created_at, updated_at, deleted_at, COUNT(*) OVER() AS total_count
FROM merchant_documents
WHERE deleted_at IS NULL AND status != 'deleted'
  AND (
    $1::TEXT IS NULL OR
    document_type ILIKE '%' || $1 || '%' OR
    status ILIKE '%' || $1 || '%' OR
    note ILIKE '%' || $1 || '%'
  )
ORDER BY document_id
LIMIT $2 OFFSET $3
`

type GetActiveMerchantDocumentsParams struct {
	Column1 string `json:"column_1"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

type GetActiveMerchantDocumentsRow struct {
	DocumentID   int32          `json:"document_id"`
	MerchantID   int32          `json:"merchant_id"`
	DocumentType string         `json:"document_type"`
	DocumentUrl  string         `json:"document_url"`
	Status       string         `json:"status"`
	Note         sql.NullString `json:"note"`
	UploadedAt   sql.NullTime   `json:"uploaded_at"`
	CreatedAt    sql.NullTime   `json:"created_at"`
	UpdatedAt    sql.NullTime   `json:"updated_at"`
	DeletedAt    sql.NullTime   `json:"deleted_at"`
	TotalCount   int64          `json:"total_count"`
}

func (q *Queries) GetActiveMerchantDocuments(ctx context.Context, arg GetActiveMerchantDocumentsParams) ([]*GetActiveMerchantDocumentsRow, error) {
	rows, err := q.db.QueryContext(ctx, getActiveMerchantDocuments, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetActiveMerchantDocumentsRow
	for rows.Next() {
		var i GetActiveMerchantDocumentsRow
		if err := rows.Scan(
			&i.DocumentID,
			&i.MerchantID,
			&i.DocumentType,
			&i.DocumentUrl,
			&i.Status,
			&i.Note,
			&i.UploadedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getMerchantDocument = `-- name: GetMerchantDocument :one
SELECT document_id, merchant_id, document_type, document_url, status, note, uploaded_at, created_at, updated_at, deleted_at
FROM merchant_documents
WHERE document_id = $1 AND deleted_at IS NULL
`

func (q *Queries) GetMerchantDocument(ctx context.Context, documentID int32) (*MerchantDocument, error) {
	row := q.db.QueryRowContext(ctx, getMerchantDocument, documentID)
	var i MerchantDocument
	err := row.Scan(
		&i.DocumentID,
		&i.MerchantID,
		&i.DocumentType,
		&i.DocumentUrl,
		&i.Status,
		&i.Note,
		&i.UploadedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const getMerchantDocuments = `-- name: GetMerchantDocuments :many
SELECT document_id, merchant_id, document_type, document_url, status, note, uploaded_at, created_at, updated_at, deleted_at, COUNT(*) OVER() AS total_count
FROM merchant_documents
WHERE deleted_at IS NULL
  AND (
    $1::TEXT IS NULL OR
    document_type ILIKE '%' || $1 || '%' OR
    status ILIKE '%' || $1 || '%' OR
    note ILIKE '%' || $1 || '%'
  )
ORDER BY document_id
LIMIT $2 OFFSET $3
`

type GetMerchantDocumentsParams struct {
	Column1 string `json:"column_1"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

type GetMerchantDocumentsRow struct {
	DocumentID   int32          `json:"document_id"`
	MerchantID   int32          `json:"merchant_id"`
	DocumentType string         `json:"document_type"`
	DocumentUrl  string         `json:"document_url"`
	Status       string         `json:"status"`
	Note         sql.NullString `json:"note"`
	UploadedAt   sql.NullTime   `json:"uploaded_at"`
	CreatedAt    sql.NullTime   `json:"created_at"`
	UpdatedAt    sql.NullTime   `json:"updated_at"`
	DeletedAt    sql.NullTime   `json:"deleted_at"`
	TotalCount   int64          `json:"total_count"`
}

func (q *Queries) GetMerchantDocuments(ctx context.Context, arg GetMerchantDocumentsParams) ([]*GetMerchantDocumentsRow, error) {
	rows, err := q.db.QueryContext(ctx, getMerchantDocuments, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetMerchantDocumentsRow
	for rows.Next() {
		var i GetMerchantDocumentsRow
		if err := rows.Scan(
			&i.DocumentID,
			&i.MerchantID,
			&i.DocumentType,
			&i.DocumentUrl,
			&i.Status,
			&i.Note,
			&i.UploadedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const getTrashedMerchantDocuments = `-- name: GetTrashedMerchantDocuments :many
SELECT document_id, merchant_id, document_type, document_url, status, note, uploaded_at, created_at, updated_at, deleted_at, COUNT(*) OVER() AS total_count
FROM merchant_documents
WHERE deleted_at IS NOT NULL
  AND (
    $1::TEXT IS NULL OR
    document_type ILIKE '%' || $1 || '%' OR
    status ILIKE '%' || $1 || '%' OR
    note ILIKE '%' || $1 || '%'
  )
ORDER BY document_id
LIMIT $2 OFFSET $3
`

type GetTrashedMerchantDocumentsParams struct {
	Column1 string `json:"column_1"`
	Limit   int32  `json:"limit"`
	Offset  int32  `json:"offset"`
}

type GetTrashedMerchantDocumentsRow struct {
	DocumentID   int32          `json:"document_id"`
	MerchantID   int32          `json:"merchant_id"`
	DocumentType string         `json:"document_type"`
	DocumentUrl  string         `json:"document_url"`
	Status       string         `json:"status"`
	Note         sql.NullString `json:"note"`
	UploadedAt   sql.NullTime   `json:"uploaded_at"`
	CreatedAt    sql.NullTime   `json:"created_at"`
	UpdatedAt    sql.NullTime   `json:"updated_at"`
	DeletedAt    sql.NullTime   `json:"deleted_at"`
	TotalCount   int64          `json:"total_count"`
}

func (q *Queries) GetTrashedMerchantDocuments(ctx context.Context, arg GetTrashedMerchantDocumentsParams) ([]*GetTrashedMerchantDocumentsRow, error) {
	rows, err := q.db.QueryContext(ctx, getTrashedMerchantDocuments, arg.Column1, arg.Limit, arg.Offset)
	if err != nil {
		return nil, err
	}
	defer rows.Close()
	var items []*GetTrashedMerchantDocumentsRow
	for rows.Next() {
		var i GetTrashedMerchantDocumentsRow
		if err := rows.Scan(
			&i.DocumentID,
			&i.MerchantID,
			&i.DocumentType,
			&i.DocumentUrl,
			&i.Status,
			&i.Note,
			&i.UploadedAt,
			&i.CreatedAt,
			&i.UpdatedAt,
			&i.DeletedAt,
			&i.TotalCount,
		); err != nil {
			return nil, err
		}
		items = append(items, &i)
	}
	if err := rows.Close(); err != nil {
		return nil, err
	}
	if err := rows.Err(); err != nil {
		return nil, err
	}
	return items, nil
}

const restoreAllMerchantDocuments = `-- name: RestoreAllMerchantDocuments :exec
UPDATE merchant_documents
SET deleted_at = NULL
WHERE deleted_at IS NOT NULL
`

func (q *Queries) RestoreAllMerchantDocuments(ctx context.Context) error {
	_, err := q.db.ExecContext(ctx, restoreAllMerchantDocuments)
	return err
}

const restoreMerchantDocument = `-- name: RestoreMerchantDocument :one
UPDATE merchant_documents
SET
    deleted_at = NULL
WHERE
    document_id = $1 AND deleted_at IS NOT NULL
RETURNING document_id, merchant_id, document_type, document_url, status, note, uploaded_at, created_at, updated_at, deleted_at
`

func (q *Queries) RestoreMerchantDocument(ctx context.Context, documentID int32) (*MerchantDocument, error) {
	row := q.db.QueryRowContext(ctx, restoreMerchantDocument, documentID)
	var i MerchantDocument
	err := row.Scan(
		&i.DocumentID,
		&i.MerchantID,
		&i.DocumentType,
		&i.DocumentUrl,
		&i.Status,
		&i.Note,
		&i.UploadedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const trashMerchantDocument = `-- name: TrashMerchantDocument :one
UPDATE merchant_documents
SET
    deleted_at = current_timestamp
WHERE
    document_id = $1 AND deleted_at IS NULL
RETURNING document_id, merchant_id, document_type, document_url, status, note, uploaded_at, created_at, updated_at, deleted_at
`

func (q *Queries) TrashMerchantDocument(ctx context.Context, documentID int32) (*MerchantDocument, error) {
	row := q.db.QueryRowContext(ctx, trashMerchantDocument, documentID)
	var i MerchantDocument
	err := row.Scan(
		&i.DocumentID,
		&i.MerchantID,
		&i.DocumentType,
		&i.DocumentUrl,
		&i.Status,
		&i.Note,
		&i.UploadedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const updateMerchantDocument = `-- name: UpdateMerchantDocument :one
UPDATE merchant_documents
SET
    document_type = $2,
    document_url = $3,
    status = $4,
    note = $5,
    updated_at = current_timestamp
WHERE
    document_id = $1 AND deleted_at IS NULL
RETURNING document_id, merchant_id, document_type, document_url, status, note, uploaded_at, created_at, updated_at, deleted_at
`

type UpdateMerchantDocumentParams struct {
	DocumentID   int32          `json:"document_id"`
	DocumentType string         `json:"document_type"`
	DocumentUrl  string         `json:"document_url"`
	Status       string         `json:"status"`
	Note         sql.NullString `json:"note"`
}

func (q *Queries) UpdateMerchantDocument(ctx context.Context, arg UpdateMerchantDocumentParams) (*MerchantDocument, error) {
	row := q.db.QueryRowContext(ctx, updateMerchantDocument,
		arg.DocumentID,
		arg.DocumentType,
		arg.DocumentUrl,
		arg.Status,
		arg.Note,
	)
	var i MerchantDocument
	err := row.Scan(
		&i.DocumentID,
		&i.MerchantID,
		&i.DocumentType,
		&i.DocumentUrl,
		&i.Status,
		&i.Note,
		&i.UploadedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}

const updateMerchantDocumentStatus = `-- name: UpdateMerchantDocumentStatus :one
UPDATE merchant_documents
SET
    status = $2,
    note = $3,
    updated_at = current_timestamp
WHERE
    document_id = $1 AND deleted_at IS NULL
RETURNING document_id, merchant_id, document_type, document_url, status, note, uploaded_at, created_at, updated_at, deleted_at
`

type UpdateMerchantDocumentStatusParams struct {
	DocumentID int32          `json:"document_id"`
	Status     string         `json:"status"`
	Note       sql.NullString `json:"note"`
}

func (q *Queries) UpdateMerchantDocumentStatus(ctx context.Context, arg UpdateMerchantDocumentStatusParams) (*MerchantDocument, error) {
	row := q.db.QueryRowContext(ctx, updateMerchantDocumentStatus, arg.DocumentID, arg.Status, arg.Note)
	var i MerchantDocument
	err := row.Scan(
		&i.DocumentID,
		&i.MerchantID,
		&i.DocumentType,
		&i.DocumentUrl,
		&i.Status,
		&i.Note,
		&i.UploadedAt,
		&i.CreatedAt,
		&i.UpdatedAt,
		&i.DeletedAt,
	)
	return &i, err
}
